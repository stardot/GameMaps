Repton levels appear to be maps of 32 row by 32 columns.

The level data was found by loading the REPTON2 file into memory in MODE 5
and visually inspecting the data. The assumption was that level data follows
the sprite data.

Level data seems to start at 0x2c00.

Setting the lowest 4 bits of the first byte in the first level to 0 results
in a blank cell; setting it to 1 results in a diamond.

Setting the highest 4 bits of the first byte to 0 produces something other
than a blank space.

Setting multiple bytes to 0 results in a group of blank cells followed by
a teleporter-style cell - the type of cell used for teleporters in Repton 2.

Each row of the level appears to be 20 bytes long. This may mean that each
cell is stored in 5 bits.


After some experimentation and reading of levels, this is the mapping between
values and cell types:

     0: space
     1: diamond
     2: boulder
     3: egg
     4: key
     5: earth
     6: earth
     7: earth
     8: safe
     9: brick wall
    10: double (top/bottom) wall
    11: double (left/right) wall
    12: quadruple wall
    13: fancy wall
    14: smooth wall
    15: lower edged smooth wall
    16: upper edged smooth wall
    17: right edged smooth wall
    18: left edged smooth wall
    19: lower right curved smooth wall
    20: lower left curved smooth wall
    21: upper right curved smooth wall
    22: upper left curved smooth wall
    23: map
    24: lower edged brick wall
    25: upper edged brick wall
    26: right edged brick wall
    27: left edged brick wall
    28: lower right curved brick wall
    29: lower left curved brick wall
    30: upper right curved brick wall
    31: upper left curved brick wall

Sprites are stored at 0x2500 in the REPTON2 file and are 8 by 16 pixels. See
the table in the sprites module of the Repton package for the offsets into the
sprite data.


Repton 2 levels appear to start at 0x2e00 and encode the data in rows of 20
bytes (5 bits per cell again).

Because the top row of Screen A is a single wall with two openings at the ends,
it is clear to see that values of 0x1f (31) are solid wall pieces and that
blank cells are 0x00 (0).

The top of Screen B appears to start at 0x2fe0. Screen A is only 24 rows high.
Many other screens are 32 rows high.

Screen C is 24 rows high.


Sprites appear to start at 0x2340.

Spirits are 4 by 8 pixels.
Other sprites are 12 by 24 pixels.

Text characters start at 0x2040.
Code appears to end at 0x1aff.

Level data
==========

Writing zero bytes into the file from 0x2001 to 0x203f results in a corrupted
Screen A and a topmost transporter that sends Repton to the leftmost skull
chamber with the palette for the level that should have been entered. This
means that the palette data is probably stored separately.

The first two bytes (0x2000, 0x2001) seem to control the displacement of the
Screen A data. The following bytes seem to control transporter destinations.

Byte 0x2028 appears to control the destination of the topmost transporter.
Byte 0x202c appears to control the transporter one square down and to the left
of it.
Byte 0x2004 appears to control the transporter to Screen B (below the first
boulder trap on the right of Screen A).

Bytes 0x2004 and 0x2005 control different aspects of the transportation. It
seems like the first byte controls what is copied into the top eight rows of
the level buffer, and the second byte controls some of the rows beneath.

It appears that each set of four bytes, from 0x2000 to 0x203f, contain four
indices into the level data which each refer to eight rows of level data.
The special index, 0x80, is the empty space at the bottom of Screen A.

By inspecting the 64 bytes of level data and comparing them to the maps on the
Stairway to Hell site, values of 0x80 and above appear to be placeholders for
eight rows that contain a single type of tile. So, 0x80 is eight rows of empty
space, 0x86 must be diamonds (as used in Screen P), and 0x83 has been tested to
be earth.

Transporters and puzzle pieces
==============================

Blanking the bytes from 0x1e50 to 0x1e8f results in a missing transporter in
the cluster under the key on Screen A.

Blanking the bytes from 0x1e00 to 0x1e3f results in missing puzzle pieces above
the skulls on Screen A.

Blanking the bytes from 0x1da0 to 0x1ddf results in a missing puzzle piece at
the top-left of Screen B. The first three bytes (01 02 06) appear to reference
the piece at x=2, y=6 where the first byte is the screen number (Screen B).

Each block of four bytes contains a screen number, x and y coordinates and
possibly a reference to the specific piece at that location. It appears that
the final number is the piece's location in the display area on Screen A.

At 0x1e50, the four bytes (00 00 08 0D) appear to represent screen number,
x and y coordinates and screen number for the transporter destination. The
following two bytes (1E 17) are the x and y coordinates of the transporter
destination.

The next entry appears at 0x1e56 (00 00 12 0B 11 18) which would indicate a
transporter at x=0, y=18 on Screen A with a destination on Screen L at x=17,
y=24. However, row 24 appears to be part of a placeholder block of eight
decorative wall rows, so the y coordinate appears to only take ordinary map
rows into account.

The end of the transporter definitions appears to be at 0x1fcf. There are zero
bytes from 0x1fd0 to 0x1fff.

Although transporters and transporter destinations are defined in the level
data, it seems that they are only there as placeholders to reserve space.

Puzzle piece sprites
--------------------

Since the puzzle piece locations are defined from 0x1da0 to 0x1e4f, there would
appear to be 44 of them. However, there are two incompletely defined entries
at 0x1e48 and 0x1e4c. In the area from 0x1c20 to 0x1d9f, there are lots of
similar bytes. Changing the first 9 to the same byte results in a redefined
puzzle piece shape for the first puzzle piece (on Screen B). The values in this
area refer to the puzzle piece sprites and are given as offsets from the start
of the sprite area (0x50 to 0x60).

Note that 42 * 9 = 378 and that the area from 0x1c20 and 0x1d9f accommodates
this number of bytes with six bytes to spare at the end.

Tile sprites
============

Since the puzzle pieces seem to be defined completely in the area described
then it is worth finding out where the other tile sprites are stored. Since
there are 32 of them, 32 * 9 = 288 (0x1c0), we can look for similar definitions
earlier in the file, possible from 0x1b00 to 0x1c1f.

This appears to work well, except that the transporter sprite is defined as
tile 11 and tile 2 is used to represent transporters in the level data.
